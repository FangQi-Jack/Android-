# **Java 的 ClassLoader**
## ClassLoader 的类型
* Bootstrap ClassLoader
    C/C++ 实现的类加载器，用于加载指定的 JDK 的核心类库，如 java.lang，java.uti 等这些系统类。Java 虚拟机的启动就是通过 Bootstrap ClassLoader 创建一个初始类来完成的。它用来加载一下目录中的类库：
    * $JAVA_HOME/jre/lib
    * -Xbootclasspath 参数指定的目录
* Extensions ClassLoader
    Java 中的实现类为 ExtClassLoader，用于加载 Java 的拓展类，提供除了系统类之外的额外功能。用来加载以下目录：
    * $JAVA_HOME/jre/lib/ext
    * 系统属性 java.ext.dir 指定的目录
* Application ClassLoader
    实现类为 AppClassLoader，也可以称作 System ClassLoader。用来加载以下目录：
    * 当前程序的 Classpath 目录
    * 系统属性 java.class.path 指定的目录
* Custom ClassLoader
    自定义类加载器，通过集成 java.lang.ClassLoader 的方式来实现自定义类加载器。
## ClassLoader 的继承关系
![](/Java 虚拟机/ClassLoader 的继承关系.png)
## 双亲委托模式
类加载器查找 Class 所采用的的是双亲委托模式，也就是首先判断该 Class 是否已经加载，如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次向上递归，直到委托到最顶层的 Bootstrap ClassLoader，如果 Bootstrap ClassLoader 找到了该 Class，则直接返回，否则继续一次向下查找，如果没有找到则最后交由自身去查找。
![](/Java 虚拟机/ClassLoader 的双亲委托模式.png)

# **Android 中的 ClassLoader**
## ClassLoader 的类型
* **BootClassLoader**
    Android 系统启动时会通过 BootClassLoader 来预加载常用类，它是由 Java 代码实现的。它是 ClassLoader 的内部类，继承了 ClassLoader，是一个单例类，在应用程序中无法直接调用。
* **DexClassLoader**
    可以加载 dex 文件和包含 dex 的压缩文件。继承自 BaseDexClassLoader，方法都在 BaseDexClassLoader 中实现。
* **PathClassLoader**
    用来加载系统类和应用程序的类。继承自 BaseDexClassLoader，方法都在 BaseDexClassLoader 中实现。
## Android 8.0 中的 ClassLoader 的继承关系
![](Android 8.0 ClassLoader 的继承关系.png)
## ClassLoader 的加载过程
Android 中的 ClassLoader 同样采用双亲委托模式。ClassLoader 的 loadClass 方法定义在 ClassLoader 中：
```
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
   // First, check if the class has already been loaded
   Class<?> c = findLoadedClass(name);
   if (c == null) {
       try {
           if (parent != null) {
               c = parent.loadClass(name, false);
           } else {
               c = findBootstrapClassOrNull(name);
           }
       } catch (ClassNotFoundException e) {
           // ClassNotFoundException thrown if class not found
           // from the non-null parent class loader
       }

       if (c == null) {
           // If still not found, then invoke findClass in order
           // to find the class.
           c = findClass(name);
       }
   }
   return c;
}
```
其中 findClass 需要子类来实现，在 BaseDexClassLoader 中：
```
public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) {
   super(parent);
   this.pathList = new DexPathList(this, dexPath, librarySearchPath, null);

   if (reporter != null) {
       reporter.report(this.pathList.getDexPaths());
   }
}
    ...
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
   List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
   Class c = pathList.findClass(name, suppressedExceptions);
   if (c == null) {
       ClassNotFoundException cnfe = new ClassNotFoundException(
               "Didn't find class \"" + name + "\" on path: " + pathList);
       for (Throwable t : suppressedExceptions) {
           cnfe.addSuppressed(t);
       }
       throw cnfe;
   }
   return c;
}
```
在 BaseDexClassLoader 的构造方法中创建了 DexPathList。在 findClass 方法中调用了 DexPathList 的 findClass 方法：
```
/**
    * Finds the named class in one of the dex files pointed at by
    * this instance. This will find the one in the earliest listed
    * path element. If the class is found but has not yet been
    * defined, then this method will define it in the defining
    * context that this instance was constructed with.
    *
    * @param name of class to find
    * @param suppressed exceptions encountered whilst finding the class
    * @return the named class or {@code null} if the class is not
    * found in any of the dex files
    */
public Class<?> findClass(String name, List<Throwable> suppressed) {
    for (Element element : dexElements) {
       Class<?> clazz = element.findClass(name, definingContext, suppressed);
       if (clazz != null) {
           return clazz;
       }
    }
    
    if (dexElementsSuppressedExceptions != null) {
       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
```
遍历 Element 数组 dexElements，并调用 Element 的 findClass 方法，Element 是 DexPathList 的静态内部类：
```
/*package*/ static class Element {
    /**
    * A file denoting a zip file (in case of a resource jar or a dex jar), or a directory
    * (only when dexFile is null).
    */
   private final File path;
   private final DexFile dexFile;
   private ClassPathURLStreamHandler urlHandler;
   private boolean initialized;
   /**
    * Element encapsulates a dex file. This may be a plain dex file (in which case dexZipPath
    * should be null), or a jar (in which case dexZipPath should denote the zip file).
    */
   public Element(DexFile dexFile, File dexZipPath) {
       this.dexFile = dexFile;
       this.path = dexZipPath;
   }

   public Element(DexFile dexFile) {
       this.dexFile = dexFile;
       this.path = null;
   }

   public Element(File path) {
     this.path = path;
     this.dexFile = null;
   }
    ...
    public Class<?> findClass(String name, ClassLoader definingContext, List<Throwable> suppressed) {
           return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null;
    }
    ...
}
```
Element 内部封装了 DexFile，用于加载 Dex。在 findClass 方法中会调用 DexFile 的 loadClassBinaryName 方法：
```
public Class loadClassBinaryName(String name, ClassLoader loader, List<Throwable> suppressed) {
   return defineClass(name, loader, mCookie, this, suppressed);
}
```
其中调用了 defineClass 方法：
   ```
private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List<Throwable> suppressed) {
   Class result = null;
   try {
       result = defineClassNative(name, loader, cookie, dexFile);
   } catch (NoClassDefFoundError e) {
       if (suppressed != null) {
           suppressed.add(e);
       }
   } catch (ClassNotFoundException e) {
       if (suppressed != null) {
           suppressed.add(e);
       }
   }
   return result;
}
```
其中调用了 defineClassNative 方法，该方法是 Native 方法。
## BootClassLoader 的创建
在 ZygoteInit 的 main 方法中：
```
public static void main(String argv[]) {
    ...
    try {
        ...
        preload(bootTimingsTraceLog);
        ...
    }
    ...
}
```
preload 方法中又调用了 ZygoteInit 的 preloadClasses 方法：
   /**
    * The path of a file that contains classes to preload.
    */
   private static final String PRELOADED_CLASSES = "/system/etc/preloaded-classes";
    ...

229    /**
230     * Performs Zygote process initialization. Loads and initializes
231     * commonly used classes.
232     *
233     * Most classes only cause a few hundred bytes to be allocated, but
234     * a few will allocate a dozen Kbytes (in one case, 500+K).
235     */
236    private static void preloadClasses() {
237        final VMRuntime runtime = VMRuntime.getRuntime();
238
239        InputStream is;
240        try {
241            is = new FileInputStream(PRELOADED_CLASSES);
242        } catch (FileNotFoundException e) {
243            Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + ".");
244            return;
245        }
246
247        Log.i(TAG, "Preloading classes...");
248        long startTime = SystemClock.uptimeMillis();
249
250        // Drop root perms while running static initializers.
251        final int reuid = Os.getuid();
252        final int regid = Os.getgid();
253
254        // We need to drop root perms only if we're already root. In the case of "wrapped"
255        // processes (see WrapperInit), this function is called from an unprivileged uid
256        // and gid.
257        boolean droppedPriviliges = false;
258        if (reuid == ROOT_UID && regid == ROOT_GID) {
259            try {
260                Os.setregid(ROOT_GID, UNPRIVILEGED_GID);
261                Os.setreuid(ROOT_UID, UNPRIVILEGED_UID);
262            } catch (ErrnoException ex) {
263                throw new RuntimeException("Failed to drop root", ex);
264            }
265
266            droppedPriviliges = true;
267        }
268
269        // Alter the target heap utilization.  With explicit GCs this
270        // is not likely to have any effect.
271        float defaultUtilization = runtime.getTargetHeapUtilization();
272        runtime.setTargetHeapUtilization(0.8f);
273
274        try {
275            BufferedReader br
276                = new BufferedReader(new InputStreamReader(is), 256);
277
278            int count = 0;
279            String line;
280            while ((line = br.readLine()) != null) {
281                // Skip comments and blank lines.
282                line = line.trim();
283                if (line.startsWith("#") || line.equals("")) {
284                    continue;
               }

               Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);
               try {
                   if (false) {
                       Log.v(TAG, "Preloading " + line + "...");
                   }
                   // Load and explicitly initialize the given class. Use
                   // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups
                   // (to derive the caller's class-loader). Use true to force initialization, and
                   // null for the boot classpath class-loader (could as well cache the
                   // class-loader of this class in a variable).
                   Class.forName(line, true, null);
                   count++;
               } catch (ClassNotFoundException e) {
                   Log.w(TAG, "Class not found for preloading: " + line);
               } catch (UnsatisfiedLinkError e) {
                   Log.w(TAG, "Problem preloading " + line + ": " + e);
               } catch (Throwable t) {
                   Log.e(TAG, "Error preloading " + line + ".", t);
                   if (t instanceof Error) {
                       throw (Error) t;
                   }
                   if (t instanceof RuntimeException) {
                       throw (RuntimeException) t;
                   }
                   throw new RuntimeException(t);
               }
               Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
           }

           Log.i(TAG, "...preloaded " + count + " classes in "
                   + (SystemClock.uptimeMillis()-startTime) + "ms.");
       } catch (IOException e) {
           Log.e(TAG, "Error reading " + PRELOADED_CLASSES + ".", e);
       } finally {
           IoUtils.closeQuietly(is);
           // Restore default.
           runtime.setTargetHeapUtilization(defaultUtilization);

           // Fill in dex caches with classes, fields, and methods brought in by preloading.
           Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadDexCaches");
           runtime.preloadDexCaches();
           Trace.traceEnd(Trace.TRACE_TAG_DALVIK);

           // Bring back root. We'll need it later if we're in the zygote.
           if (droppedPriviliges) {
               try {
                   Os.setreuid(ROOT_UID, ROOT_UID);
                   Os.setregid(ROOT_GID, ROOT_GID);
               } catch (ErrnoException ex) {
                   throw new RuntimeException("Failed to restore root", ex);
               }
           }
       }
   }
