# **Java 虚拟机**
## Java 虚拟机的执行流程
Java 虚拟机的执行流程分为两部分：编译时环境和运行时环境。当一个 Java 文件被 Java 编译器编译成 Class 文件后，才能由 Java 虚拟机进行处理。Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。
## Java 虚拟机的结构
![](Java 虚拟机的结构.png)

## 类的生命周期
1、**加载**：查找并加载 Class 文件
2、**链接**：包括**验证**、**准备**和**解析**
* **验证**：确保被导入类型的正确性
* **准备**：为类的静态字段分配字段，并用默认值初始化这些字段
* **解析**：虚拟机将常量池内的符号引用替换为直接引用
3、**初始化**：将类变量初始化为正确的初始值
4、**使用**
5、**卸载**

加载阶段主要做了 3 件事情：
* **根据特定名称查找类或接口类型的二进制字节流**
* **将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构**
* **在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口**

## 类加载子系统
**1、Bootstrap ClassLoader（引导类加载器）**
用 C/C++ 代码实现的加载器，用于加载指定的 JDK 的核心类库。用来加载以下目录：
* $JAVA_HOME/jre/lib
* -Xbootclasspath 参数指定的目录
Java 虚拟机的启动就是通过引导类加载器创建一个初始类来完成的。该加载器不能被 Java 代码访问。
**2、Extensions ClassLoader（拓展类加载器）**
用于加载 Java 的拓展类，提供除了系统类之外的额外功能。用来加载以下目录：
* $JAVA_HOME/jre/lib/ext
* 系统属性 java.ext.dir 所指定的目录
**3、Application ClassLoader（应用程序类加载器）**
也称作 System ClassLoader，可以通过 ClassLoader 的 getSystemClassLoader 方法获取到。用来加载以下目录：
* 当前应用程序 Classpath 目录
* 系统属性 java.class.path 指定的目录

## 运行时数据区
**1、程序计数器**
也叫作 PC 寄存器，是一块较小的内存空间。字节码解释器工作时通过改变程序计数器来选取下一条需要执行的字节码指令。为了在线程切换后能恢复到正确的执行位置，每一个线程都有一个独立的程序计数器，因此程序计数器是线程私有的。程序计数器是 Java 虚拟机规范中唯一没有规定任何 OutOfMemoryError 的数据区域。
**2、Java 虚拟机栈**
每个线程都有一个私有的 Java 虚拟机栈，他的生命周期与线程相同，与线程同时创建。用来存储线程中 java 方法调用的状态，包括局部变量、参数、返回值以及运算的中间结果等。一个 Java 虚拟机栈包含多个栈帧，一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。Java 虚拟机规范中定义了两种异常情况：
* 如果线程请求分配的栈容量超过 Java 虚拟机所允许的最大容量，会抛出 StackOverflowError。
* 如果 Java 虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，或者在创建新线程时没有足够的内存去创建对应的 java 虚拟机栈，则会抛出 OutOfMemoryError。
**3、本地方法栈**
Java 虚拟机的实现可能要用到 C Stacks 来支持 Native 语言，C Stacks 就是本地方法栈。也会抛出 StackOverflowError 和 OutOfMemoryError。
**4、Java 堆**
所有线程共享的运行时内存区域，用来存放对象实例。存储的对象被垃圾收集器管理，这些被管理的对象无法显示的销毁。Java 堆的内存在物理上不需要连续，在逻辑上连续即可。Java 虚拟机规范中定义了一种异常情况：
* 如果在堆中没有足够的内存来完成实例分配，并且堆也无法进行扩展时，会抛出 OutOfMemoryError。
**5、方法区**
所有线程共享的运行时内存区域，用来存储已经被 Java 虚拟机加载的类的结构信息，包括运行时常量池、字段和方法信息、静态变量的数据。它是 Java 堆的逻辑组成部分。方法区中可以选择不实现垃圾收集。Java 虚拟机规范中定义了一种异常情况：
* 如果方法区的内存空间不满足内存分配需求时，会抛出 OutOfMemoryError。
**6、运行时常量池**
方法区的一部分。用来存放编译时期生成的字面量和符号引用，这些内容会在类加载后存放在方法区的运行时常量池中。可以理解为类或接口的常量池的运行时表现形式。Java 虚拟机规范中定义了一种异常情况：
* 当创建类或接口时，如果构造运行时常量池所需的内存超过了方法区所能提供的最大值，会抛出 OutOfMemoryError。

## 对象的创建
**1、判断对象对应的类是否加载、链接和初始化**
**2、为对象分配内存**
有两种方式：
*  *指针碰撞* ：如果 Java 堆的内存是规整的，即所有用过的内存在一边，空闲的内存在另一边。分配内存时将位于中间的指针指示器向空闲区移动一段与对象大小相等的距离，完成内存分配工作。
*  *空闲列表* ：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存时可用的，分配内存时从列表中查询到足够大的内存分配给对象，而后更新列表记录。
**3、处理并发安全问题**
有两种方式：
* 堆分配内存空间的动作进行同步处理，比如在虚拟机采用 CAS 算法并配上失败重试的方式保证更新操作的原子性
* 每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），线程需要分配内存时，就在对应的 TLAB 上进行分配，当 TLAB 用完并且被分配到了新的 TLAB 时，这时候才需要同步锁定。
**4、初始化分配到的内存空间**
**5、设置对象的对象头**
**6、执行 init 方法进行初始化**

## 对象的堆内存布局
* 对象头
* 实例数据
* 对齐填充

## 垃圾标记算法
### 引用计数算法
基本思想是每个对象都有一个引用计数器，在对象被引用时加 1，引用失效时减 1。无法解决对象之间循环引用的问题。
### 根搜索算法
基本思想是选定一些对象作为 GC Roots，并组成根对象集合，然后以这些 GC Roots 的对象作为起点，向下搜索，如果目标对象到 GC Roots 是连接着的，则称目标对象是可达的，否则就说明目标对象不可达，是可以被回收的。
在 Java 中可以作为 GC Roots 的对象主要有：
* Java 栈中引用的对象
* 本地方法栈中 JNI 引用的对象
* 方法区中运行时常量池引用的对象
* 方法区中静态属性引用的对象
* 运行中的线程
* 由引导类加载器加载的对象
* GC 控制的对象

## Java 对象在虚拟机中的生命周期
**1、创建阶段（Created）**
(1)为对象分配存储空间
(2)构造对象
(3)从父类到子类堆s

