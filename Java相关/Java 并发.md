## Java 内存模型

Java 内存模型的主要目的是定义程序中各种变量的访问规则。



### 主内存（Main Memory）与工作内存（Working Memory）

Java 内存模型规定了所有的变量都存储在主内存中。每条线程都有自己的工作内存，保存了该线程使用的变量和主内存副本，线程对变量的所有读写操作都必须在工作内存中进行。不同线程之间也无法直接访问对方的工作内存，线程间的变量传递必须经过主内存。

**主内存、工作内存与 Java 内存区域中的堆、栈、方法区并不是同一个层次的对内存的划分。**



### 内存见的交互操作

Java 内存模型定义了 8 中操作来完成内存交互：

* **lock（锁定）**：作用于主内存的变量，把一个变量表示为一个线程独占的状态。
* **unlock（解锁）**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。
* **read（读取）**：作用于主内存的变量，把一个变量的值从主内存传输到工作内存中，一边随后的 load 操作使用。
* **load（载入）**：作用于工作内存的变量，把一个 read 操作从主内存中读取到的变量值放入工作内存的变量副本中。
* **use（使用）**：作用于工作内存中的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将执行这个操作。
* **assign（赋值）**：作用于工作内存的变量，把从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将执行这个操作。
* **store（存储）**：作用于工作内存的变量，把工作内存中一个变量的值传递到主内存中，以便之后的 write 操作使用。
* **write（写入）**：作用于主内存的变量，把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

Java 内存模型还规定了在执行上述 8 中基本操作时必须满足以下规则：

* **不允许 read 和 load、store 和 write 操作之一单独出现。**即不允许一个变量从主内存中读取了但工作内存不接受或者工作内存发起回写但主内存不接受的情况。
* **不允许一个线程丢弃它最近的 assign 操作。**即变量在工作内存中改变了之后必须要同步回主内存中。
* **不允许一个线程在没有执行 assign 操作时把数据同步回主内存。**
* **一个新的变量只能在主内存中诞生。**即不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量。
* **一个变量在同一时刻只允许一个线程对其进行 lock 操作，但 lock 操作可以被同一个线程重复执行多次，只有执行相同次数的 unlock 操作之后变量才会被解锁。**
* **如果对一个变量执行了 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。**
* **如果一个变量没有被执行过 lock 操作，就不允许对它进行 unlock 操作，也不允许对其一个被他线程锁定的变量执行 unlock 操作。**
* **对一个变量执行 unlock 操作之前，必须先把它同步回主内存中，即执行 store 和 write 操作。**



### 原子性、可见性和有序性

#### 1、原子性（Atomicity）

由 Java 内存模型直接保证的原子性变量操作包括：read、load、assign、use、store 和 write。大致可以认为对基本数据类型的访问、读写都具备原子性。

#### 2、可见性（Visibility）

指当一个线程修改了某个变量的值时，其他线程能够立即得知这个修改。Java 内存模型通过在变量修改后同步回主内存，在变量读取前从主内存刷新变量值来实现可见性。`volatile` 关键字就是如此，此外 `synchronized` 和 `final` 两个关键字也能保证可见性。`final` 的可见性是指：被 `final` 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 `this` 的引用传递出去，那么其他线程中就能看见 `final` 字段的值。

#### 3、有序性（Ordering）

Java 程序中天然的有序性：**在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的**。Java 语言提供了 `volatile` 和 `synchronized` 两个关键字来保证线程间操作的有序性。`volatile` 包含了禁止指令重排序的语义，`synchoronized` 则是由“一个变量在同一个时刻只允许一个线程对其进行 lock 操作”保证的。



### 先行发生原则（Happens-Before）

它是判断数据是否存在竞争，线程是否安全的非常有用的手段。Java 内存模型下一些天然的先行发生关系：

* **程序次序规则（Program Order Rule）**：在一个线程内，按照控制流的顺序，书写在前面的操作先行发生于书写在后面的操作。
* **管程锁定规则（Monitor Lock Rule）**：一个 unlock 操作先行发生于*后面*对*同一个锁*的 lock 操作。
* **volatile 变量规则（Volatile Variable Rule）**：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
* **线程启动规则（Thread Start Rule）**：Thread 对象的 start() 方法先行发生于此线程的每一个动作。
* **线程终止规则（Thread Termination Rule）**：线程中的所有操作都先行发生于对此线程的终止检测。
* **线程中断规则（Thread Interruption Rule）**：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
* **对象终结规则（Finalizer Rule）**：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
* **传递性（Transitivity）**：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

Java 语言无须任何同步手段保障就能成立的先行发生规则**有且只有**上面这些。



### volatile 关键字

当一个变量被定义成 volatile 后，它具备两项特性：**1、保证此变量对所有线程的可见性。2、禁止指令重排序优化。**由于 volatile 只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要通过加锁来保证原子性：

* 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
* 变量不需要于其他的状态变量共同参与不变约束。



### 线程安全

TODO



